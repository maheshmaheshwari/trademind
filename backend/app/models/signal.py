"""
Signal Model

Stores generated trading signals.
"""

from datetime import date, datetime
from typing import Optional

from sqlalchemy import Date, DateTime, Float, ForeignKey, Index, Integer, String, Text, UniqueConstraint
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.database import Base


class Signal(Base):
    """Trading signal generated by the ML model."""
    
    __tablename__ = "signals"
    
    # Foreign key
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False
    )
    
    # Date
    date: Mapped[date] = mapped_column(Date, nullable=False, index=True)
    
    # Signal details
    signal_type: Mapped[str] = mapped_column(String(10), nullable=False)  # BUY, HOLD, AVOID
    
    # Probabilities
    probability_buy: Mapped[float] = mapped_column(Float, nullable=False)
    probability_hold: Mapped[float] = mapped_column(Float, nullable=False)
    probability_avoid: Mapped[float] = mapped_column(Float, nullable=False)
    
    # Confidence and scores
    confidence: Mapped[float] = mapped_column(Float, nullable=False)  # 0-1 scale
    risk_reward_ratio: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    
    # Suggested timeframe (in days)
    suggested_timeframe_days: Mapped[int] = mapped_column(Integer, default=10)
    
    # Entry/Exit suggestions
    suggested_entry: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    suggested_stop_loss: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    suggested_target: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    
    # Model info
    model_version: Mapped[str] = mapped_column(String(50), nullable=False)
    
    # Additional context
    reasoning: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # Timestamps
    generated_at: Mapped[datetime] = mapped_column(
        DateTime, 
        default=datetime.utcnow,
        nullable=False
    )
    
    # Relationship
    stock = relationship("Stock", back_populates="signals")
    
    # Constraints and indexes
    __table_args__ = (
        UniqueConstraint("stock_id", "date", "model_version", name="uq_signal_stock_date_version"),
        Index("ix_signal_stock_date", "stock_id", "date"),
        Index("ix_signal_type", "signal_type"),
        Index("ix_signal_confidence", "confidence"),
        Index("ix_signal_generated_at", "generated_at"),
    )
    
    def __repr__(self) -> str:
        return f"<Signal(stock_id={self.stock_id}, date={self.date}, signal={self.signal_type})>"
    
    @property
    def is_actionable(self) -> bool:
        """Check if signal is actionable (high confidence BUY)."""
        return self.signal_type == "BUY" and self.confidence >= 0.7
    
    @property
    def risk_percent(self) -> Optional[float]:
        """Calculate risk as percentage from entry to stop loss."""
        if self.suggested_entry and self.suggested_stop_loss:
            return abs(self.suggested_entry - self.suggested_stop_loss) / self.suggested_entry * 100
        return None
    
    @property
    def reward_percent(self) -> Optional[float]:
        """Calculate reward as percentage from entry to target."""
        if self.suggested_entry and self.suggested_target:
            return abs(self.suggested_target - self.suggested_entry) / self.suggested_entry * 100
        return None
